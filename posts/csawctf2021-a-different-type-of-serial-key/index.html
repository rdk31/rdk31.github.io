<!doctype html><html><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title> rdk31's blog </title><link href=https://rdk31.com/fonts.css rel=stylesheet><script async data-goatcounter=https://rdk31.goatcounter.com/count src=https://rdk31.com/js/count.js></script><noscript><img src="https://rdk31.goatcounter.com//count?p=/posts/csawctf2021-a-different-type-of-serial-key/&t=CSAW CTF Qualification Round 2021 - A Different Type of Serial Key"></noscript><link title="rdk31's blog" href=https://rdk31.com/atom.xml rel=alternate type=application/atom+xml><link href=https://rdk31.com/theme/light.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=https://rdk31.com/theme/dark.css rel=stylesheet><link href=https://rdk31.com/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://rdk31.com>rdk31's blog</a></div><nav><a style="margin-left: 0.7em" href=/posts>/posts</a><a style="margin-left: 0.7em" href=/tags>/tags</a><a style="margin-left: 0.7em" href=/about>/about</a></nav></header><main><article><div class=title><div class=page-header>CSAW CTF Qualification Round 2021 - A Different Type of Serial Key<span style="font-size: 1.6em" class=primary-color>.</span></div><div class=meta>Posted on 2021-09-13</div></div><section class=body><h1 id=a-different-type-of-serial-key>A Different Type of Serial Key</h1><h2 id=task-description>Task description</h2><p>Attached are serial captures of two different uploads to an embedded device. One of these uploads is a key and the other is a function block. Your goal is to decode the serial traffic, extract the key and function block, and use these to find the flag. The flag will be in format flag{}.<p>Author: CISA<p><a href=files/capture.sal>capture.sal</a> <a href=files/key.sal>key.sal</a><h2 id=solution>Solution</h2><h3 id=key-sal>key.sal</h3><p>Opening it up in Logic it looks like I2C with data (SDA) on channel 1 and clock (SCL) on channel 0.<p><img src=images/key.png><p>Applying the I2C analyzer confirms it.<p><img src=images/key-decoded.png><p>After exporting to csv we can extract the bytes using this simple python script:<pre class=language-py3 data-lang=py3 style=background-color:#2b303b;color:#c0c5ce;><code class=language-py3 data-lang=py3><span style=color:#b48ead;>with </span><span style=color:#96b5b4;>open</span><span>("</span><span style=color:#a3be8c;>key.csv</span><span>") </span><span style=color:#b48ead;>as </span><span>f:
</span><span>    f.</span><span style=color:#bf616a;>readline</span><span>()  </span><span style=color:#65737e;># skipping the csv header
</span><span>    </span><span style=color:#b48ead;>for </span><span>l </span><span style=color:#b48ead;>in </span><span>f.</span><span style=color:#bf616a;>readlines</span><span>():
</span><span>        l = l[:-</span><span style=color:#d08770;>1</span><span>]
</span><span>        byte = l.</span><span style=color:#bf616a;>split</span><span>("</span><span style=color:#a3be8c;>,</span><span>")[</span><span style=color:#d08770;>3</span><span>]
</span><span>        </span><span style=color:#96b5b4;>print</span><span>(</span><span style=color:#b48ead;>f</span><span>"{byte}</span><span style=color:#a3be8c;>,</span><span>", </span><span style=color:#bf616a;>end</span><span>="")
</span></code></pre><h3 id=capture-sal>capture.sal</h3><p>Opening it up in Logic we see two communications.<p><img src=images/capture-zoomed-out.png><p>Zooming in it looks like SPI with MOSI on channel 3, MISO on channel 2, clock on channel 0 and chip select on channel 1.<p><img src=images/capture.png><p>Enabling the SPI analyzer confirms it.<p><img src=images/capture-decoded.png><p>After exporting the data to csv, I manually splitted the file into two separate communications and using this script I turned them into binaries.<pre class=language-py3 data-lang=py3 style=background-color:#2b303b;color:#c0c5ce;><code class=language-py3 data-lang=py3><span style=color:#b48ead;>with </span><span style=color:#96b5b4;>open</span><span>("</span><span style=color:#a3be8c;>capture.bin</span><span>", "</span><span style=color:#a3be8c;>wb</span><span>") </span><span style=color:#b48ead;>as </span><span>b:
</span><span>    </span><span style=color:#b48ead;>with </span><span style=color:#96b5b4;>open</span><span>("</span><span style=color:#a3be8c;>capture.csv</span><span>") </span><span style=color:#b48ead;>as </span><span>f:
</span><span>        f.</span><span style=color:#bf616a;>readline</span><span>()
</span><span>        </span><span style=color:#b48ead;>for </span><span>l </span><span style=color:#b48ead;>in </span><span>f.</span><span style=color:#bf616a;>readlines</span><span>():
</span><span>            l = l[:-</span><span style=color:#d08770;>1</span><span>]
</span><span>            c = l.</span><span style=color:#bf616a;>split</span><span>("</span><span style=color:#a3be8c;>,</span><span>")[</span><span style=color:#d08770;>2</span><span>]
</span><span>            b.</span><span style=color:#bf616a;>write</span><span>(int.</span><span style=color:#bf616a;>to_bytes</span><span>(</span><span style=color:#bf616a;>int</span><span>(c, </span><span style=color:#d08770;>16</span><span>), </span><span style=color:#d08770;>1</span><span>, </span><span style=color:#bf616a;>byteorder</span><span>="</span><span style=color:#a3be8c;>big</span><span>"))
</span></code></pre><p>Running <code>file</code> on both of them showed <code>Motorola S-Record; binary data in text format</code>. According to <a href=https://en.wikipedia.org/wiki/SREC_(file_format)>wikipedia</a> the first line (header) contains vendor specific ASCII text right after S0XXYYYY (X - byte count, Y - address).<p>And indeed it does, <code>4C6F63616C204B6579B</code> translates to <code>Local Key.</code> and <code>506F77657250432042696720456E6469616E2033322D42697420537475620E</code> to <code>PowerPC Big Endian 32-Bit Stub.</code><p>Let's try the second file in ghidra.<p><img src=images/capture-ghidra.png><p>And this is the code ghidra decompiled:<pre class=language-c data-lang=c style=background-color:#2b303b;color:#c0c5ce;><code class=language-c data-lang=c><span style=color:#b48ead;>void </span><span style=color:#8fa1b3;>UndefinedFunction_000004ec</span><span>(</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>param_1</span><span>,</span><span style=color:#b48ead;>int </span><span style=color:#bf616a;>param_2</span><span>)
</span><span>{
</span><span>  uint uStack20;
</span><span>
</span><span>  uStack20 = </span><span style=color:#d08770;>0</span><span>;
</span><span>  </span><span style=color:#b48ead;>while </span><span>((</span><span style=color:#b48ead;>int</span><span>)uStack20 < </span><span style=color:#d08770;>0x1d</span><span>) {
</span><span>    </span><span style=color:#b48ead;>if </span><span>((uStack20 & </span><span style=color:#d08770;>1</span><span>) == </span><span style=color:#d08770;>0</span><span>) {
</span><span>      *(byte *)(param_2 + uStack20) =
</span><span>           *(byte *)(param_1 + uStack20) ^ *(</span><span style=color:#b48ead;>char </span><span>*)(_DAT_10020018 + uStack20) - </span><span style=color:#d08770;>3</span><span style=color:#b48ead;>U</span><span>;
</span><span>    }
</span><span>    </span><span style=color:#b48ead;>else </span><span>{
</span><span>      </span><span style=color:#b48ead;>if </span><span>((</span><span style=color:#b48ead;>int</span><span>)uStack20 % </span><span style=color:#d08770;>3 </span><span>== </span><span style=color:#d08770;>0</span><span>) {
</span><span>        *(byte *)(param_2 + uStack20) =
</span><span>             *(byte *)(param_1 + uStack20) ^ *(</span><span style=color:#b48ead;>char </span><span>*)(_DAT_10020018 + uStack20) + </span><span style=color:#d08770;>5</span><span style=color:#b48ead;>U</span><span>;
</span><span>      }
</span><span>      </span><span style=color:#b48ead;>else </span><span>{
</span><span>        *(byte *)(param_2 + uStack20) =
</span><span>             *(byte *)(param_1 + uStack20) ^ *(byte *)(_DAT_10020018 + uStack20);
</span><span>      }
</span><span>    }
</span><span>    uStack20 = uStack20 + </span><span style=color:#d08770;>1</span><span>;
</span><span>  }
</span><span>  *(undefined *)(param_2 + </span><span style=color:#d08770;>0x1d</span><span>) = </span><span style=color:#d08770;>0</span><span>;
</span><span>  </span><span style=color:#b48ead;>return</span><span>;
</span><span>}
</span></code></pre><p>Basically a loop xoring two arrays with some minor modifications.<p>Extracting the bytes out of the local key (using wikipedia's info about SREC) and putting everything together gives us:<pre class=language-py3 data-lang=py3 style=background-color:#2b303b;color:#c0c5ce;><code class=language-py3 data-lang=py3><span>key = [
</span><span>    </span><span style=color:#d08770;>0x59</span><span>, </span><span style=color:#d08770;>0x57</span><span>, </span><span style=color:#d08770;>0x72</span><span>, </span><span style=color:#d08770;>0x31</span><span>, </span><span style=color:#d08770;>0x79</span><span>, </span><span style=color:#d08770;>0xCE</span><span>, </span><span style=color:#d08770;>0x94</span><span>,
</span><span>    </span><span style=color:#d08770;>0x8D</span><span>, </span><span style=color:#d08770;>0x15</span><span>, </span><span style=color:#d08770;>0xD4</span><span>, </span><span style=color:#d08770;>0x54</span><span>, </span><span style=color:#d08770;>0x02</span><span>, </span><span style=color:#d08770;>0x7C</span><span>, </span><span style=color:#d08770;>0x5C</span><span>,
</span><span>    </span><span style=color:#d08770;>0xA0</span><span>, </span><span style=color:#d08770;>0x83</span><span>, </span><span style=color:#d08770;>0x3D</span><span>, </span><span style=color:#d08770;>0xAC</span><span>, </span><span style=color:#d08770;>0xB7</span><span>, </span><span style=color:#d08770;>0x2A</span><span>, </span><span style=color:#d08770;>0x17</span><span>,
</span><span>    </span><span style=color:#d08770;>0x67</span><span>, </span><span style=color:#d08770;>0x76</span><span>, </span><span style=color:#d08770;>0x38</span><span>, </span><span style=color:#d08770;>0x98</span><span>, </span><span style=color:#d08770;>0x8F</span><span>, </span><span style=color:#d08770;>0x69</span><span>, </span><span style=color:#d08770;>0xE8</span><span>,
</span><span>    </span><span style=color:#d08770;>0xD0</span><span>,
</span><span>]
</span><span>
</span><span>local_key = [
</span><span>    </span><span style=color:#d08770;>0x42</span><span>, </span><span style=color:#d08770;>0x3B</span><span>, </span><span style=color:#d08770;>0x16</span><span>, </span><span style=color:#d08770;>0x51</span><span>, </span><span style=color:#d08770;>0x05</span><span>, </span><span style=color:#d08770;>0xBD</span><span>, </span><span style=color:#d08770;>0xAA</span><span>,
</span><span>    </span><span style=color:#d08770;>0xFF</span><span>, </span><span style=color:#d08770;>0x27</span><span>, </span><span style=color:#d08770;>0xDB</span><span>, </span><span style=color:#d08770;>0x3B</span><span>, </span><span style=color:#d08770;>0x5D</span><span>, </span><span style=color:#d08770;>0x22</span><span>, </span><span style=color:#d08770;>0x34</span><span>,
</span><span>    </span><span style=color:#d08770;>0x97</span><span>, </span><span style=color:#d08770;>0xEA</span><span>, </span><span style=color:#d08770;>0x54</span><span>, </span><span style=color:#d08770;>0x9F</span><span>, </span><span style=color:#d08770;>0xDC</span><span>, </span><span style=color:#d08770;>0x4D</span><span>, </span><span style=color:#d08770;>0x27</span><span>,
</span><span>    </span><span style=color:#d08770;>0x33</span><span>, </span><span style=color:#d08770;>0x08</span><span>, </span><span style=color:#d08770;>0x08</span><span>, </span><span style=color:#d08770;>0xF7</span><span>, </span><span style=color:#d08770;>0xF9</span><span>, </span><span style=color:#d08770;>0x5D</span><span>, </span><span style=color:#d08770;>0x95</span><span>,
</span><span>    </span><span style=color:#d08770;>0xB0
</span><span>]
</span><span>
</span><span>flag = ""
</span><span>
</span><span style=color:#b48ead;>for </span><span>i </span><span style=color:#b48ead;>in </span><span style=color:#96b5b4;>range</span><span>(</span><span style=color:#96b5b4;>len</span><span>(key)):
</span><span>    </span><span style=color:#b48ead;>if </span><span>i % </span><span style=color:#d08770;>2 </span><span>== </span><span style=color:#d08770;>0</span><span>:
</span><span>        flag += </span><span style=color:#96b5b4;>chr</span><span>(key[i] ^ local_key[i] - </span><span style=color:#d08770;>3</span><span>)
</span><span>    </span><span style=color:#b48ead;>else</span><span>:
</span><span>        </span><span style=color:#b48ead;>if </span><span>i % </span><span style=color:#d08770;>3 </span><span>== </span><span style=color:#d08770;>0</span><span>:
</span><span>            flag += </span><span style=color:#96b5b4;>chr</span><span>(key[i] ^ local_key[i] + </span><span style=color:#d08770;>5</span><span>)
</span><span>        </span><span style=color:#b48ead;>else</span><span>:
</span><span>            flag += </span><span style=color:#96b5b4;>chr</span><span>(key[i] ^ local_key[i])
</span><span>
</span><span style=color:#96b5b4;>print</span><span>(flag)
</span></code></pre><p>The flag: <code>flag{s3r14l_ch4ll3ng3_s0lv3r}</code></section></article></main><div class=post-footer><div class=post-tags>tags: <a href=https://rdk31.com/tags/ctf/>#ctf</a><a href=https://rdk31.com/tags/embedded/>#embedded</a></div><div class=post-nav><a class=previous href=https://rdk31.com/posts/csawctf2021-ncore/>‹ CSAW CTF Qualification Round 2021 - ncore</a><a class=next href=https://rdk31.com/posts/csawctf2021-alien-math/>CSAW CTF Qualification Round 2021 - Alien Math ›</a></div></div></div>